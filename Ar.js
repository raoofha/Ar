/*; xterm-send "echo -ne \"\\033c\"; node $0" ; exit 1 ; */

inc = (a) => (typeof(a.v)==="bigint") ? a : 1n+a
sub = (a,b) => (typeof(a.v)==="bigint") ? a : ((typeof(b.v)==="bigint") ? b : 0n+a-b)
mul = (a,b) => (typeof(a.v)==="bigint") ? a : ((typeof(b.v)==="bigint") ? b : 0n+a*b)
div = (a,b) => (typeof(a.v)==="bigint") ? a : ((typeof(b.v)==="bigint") ? b : ((b!==0n) ? 0n+a/b : {v:a,toString(a){return this.v.toString(a);},valueOf(){return this.v;}}))
/* for correct logging of gap values */ const originalLog = console.log; console.log = (...args) => originalLog(...args.map((a)=>a.valueOf?a.valueOf():a));

zero = (a) => sub(a,a)
one = (a) => inc(zero(a))
two = (a) => inc(one(a))
three = (a) => inc(two(a))
negate = (a) => sub(zero(a),a)
add = (a,b) => sub(a,negate(b))
rem = (a,b) => sub(a,mul(b,div(a,b)))
square = (a) => mul(a,a)
isNonZero = (a) => div(square(sub(square(a),one(a))),square(add(square(a),one(a))))
isZero = (a) => isNonZero(isNonZero(a))
not = (a) => isNonZero(a)
and = (a,b) => isZero(add(isZero(a),isZero(b)))
or = (a,b) => isZero(mul(a,b))
eq = (a,b) => isZero(sub(a,b))
notEq = (a,b) => not(eq(a,b))
divz = (a,b) => div(a,add(b,isNonZero(b)))
If = (a,b,c) => add(mul(isNonZero(a),b),mul(isZero(a),c))
isNegative = (a) => If(isZero(a),one(a),isNonZero(divz(sub(one(a),a),a)))
isPositive = (a) => not(isNegative(a))
lt = (a,b) => If(eq(a,b),one(a),If(and(isNegative(a),isPositive(b)),zero(a),If(and(isPositive(a),isNegative(b)),one(a),If(and(isNegative(a),isNegative(b)),isZero(divz(b,a)),isZero(divz(a,b))))))
gt = (a,b) => and(not(lt(a,b)),not(eq(a,b)))
lte = (a,b) => or(eq(a,b),lt(a,b))
gte = (a,b) => or(eq(a,b),gt(a,b))
sign = (a) => If(isNegative(a),sub(zero(a),one(a)),If(eq(a,zero(a)),zero(a),one(a)))
tsub = (a,b) => If(lt(a,b),zero(a),sub(a,b))
min = (a,b) => If(lt(a,b),a,b)
max = (a,b) => If(lt(a,b),b,a)
absolutevalue = (a) => mul(sign(a),a)
absolutedifference = (a,b) => absolutevalue(sub(a,b))
isDivisible = (a,b) => isZero(rem(a,b))
isEven = (a) => isDivisible(a,two(a))
isOdd = (a) => not(isEven(a))
sum = (a,b) => div(mul(add(a,b),add(sub(b,a),one(a))),two(a))
cantorPair = (a,b) => div(add(add(add(add(mul(a,a),a),mul(two(a),mul(a,b))),mul(three(a),b)),mul(b,b)),two(a))

// ////////////////////////////////////////////////////////////////////////
const test = (a,b) => { let x; try { x=eval(a); } catch(e) { x = e; } if(b!==undefined) { if( x.toString()!==b.toString() ) /*console.trace()*/ console.log('\x1b[31m%s\x1b[0m', a, "===" ,x,b); } else console.log(a,"===",x); }

TRUE = 0n
FALSE = 1n

test("inc(0n)",1n)
test("inc(negate(1n))",0n)
test("negate(1n)",-1n)
test("add(2n,2n)",4n)
test("add(10n,10n)",20n)
test("add(33n,11n)",44n)
test("mul(2n,4n)",8n)
test("mul(10n,10n)",100n)
test("mul(negate(10n),0n)",0n)
test("div(10n,0n)",10n)
test("divz(10n,0n)",10n)
test("rem(10n,0n)",10n)
test("negate(42n)",-42n)
test("isZero(42n)",FALSE)
test("isZero(0n)",TRUE)
test("isZero(negate(42n))",FALSE)
test("eq(0n,0n)",TRUE)
test("eq(0n,0n)",TRUE)
test("eq(0n,4n)",FALSE)
test("isDivisible(42n,2n)",TRUE)
test("isDivisible(42n,4n)",FALSE)
test("isEven(42n)",TRUE)
test("isEven(43n)",FALSE)
test("isOdd(43n)",TRUE)
test("absolutevalue(negate(43n))",43n)
test("absolutedifference(negate(43n),43n)",86n)
test("sign(42n)",1n)
test("sign(0n)","0")
test("sign(negate(42n))",-1n)
test("min(42n,negate(42n))",-42n)
test("max(42n,negate(42n))",42n)
test("sum(0n,100n)",100n*101n/2n)
test("sum(negate(100n),100n)","0")
test("cantorPair(2n,3n)",18n)
test("add(42n,42n)",84n)
test("isZero(42n)",FALSE)
test("isZero(negate(42n))",FALSE)
test("isZero(0n)",TRUE)
test("eq(0n,0n)",TRUE)
test("eq(0n,4n)",FALSE)
test("notEq(0n,0n)",FALSE)
test("notEq(0n,4n)",TRUE)
test("If(TRUE,42n,20n)",42n)
test("If(FALSE,42n,20n)",20n)
test("isNegative(42n)",1n)
test("isNegative(0n)",FALSE)
test("isPositive(0n)",TRUE)
test("add(div(2n,0n),div(1n,0n))",2n)
test("add(div(1n,0n),div(2n,0n))",1n)
test("add(1n,div(0n,0n))",0n)
